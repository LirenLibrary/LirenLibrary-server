import groovy.sql.Sql

ext {
    databaseMigrationBaseDir = 'database'
    liquibaseChangeLogFile = "${databaseMigrationBaseDir}/changelogs/changelog.xml"
    liquibaseChangeLogTable = 'liquibase_change_log'
    liquibaseChangeLogLockTable = 'liquibase_change_log_lock'
    liquibaseRollbackCount = 1
}


ant {
    ant.path(id: 'mysqlClasspath') {
        ant.pathelement(path: configurations.mysql.asPath)
    }
    taskdef resource: 'liquibasetasks.properties', classpath: configurations.liquibase.asPath

}

task updateDatabase {
    description 'Update to latest database.'
    group = 'liquibase'
}

updateDatabase << {
    ant {
        updateDatabase(
                changeLogFile: liquibaseChangeLogFile,
                driver: dbConnectionDriver,
                url: dbConnectionUrl,
                username: dbConnectionUsername,
                password: dbConnectionPassword,
                promptOnNonLocalDatabase: 'false',
                dropFirst: 'false',
                classpathref: 'mysqlClasspath',
                databasechangelogtablename: liquibaseChangeLogTable,
                databasechangeloglocktablename: liquibaseChangeLogLockTable
        )
    }
}


task rollbackDatabase {
    description 'Rollback database migration.'
    group 'liquibase'

}

rollbackDatabase << {
    ant {
        rollbackDatabase(
                changeLogFile: liquibaseChangeLogFile,
                driver: dbConnectionDriver,
                url: dbConnectionUrl,
                username: dbConnectionUsername,
                password: dbConnectionPassword,
                classpathref: 'mysqlClasspath',
                rollbackcount: liquibaseRollbackCount,
                databasechangelogtablename: liquibaseChangeLogTable,
                databasechangeloglocktablename: liquibaseChangeLogLockTable
        )
    }
}

updateDatabase.dependsOn 'loadDatabaseProps'
rollbackDatabase.dependsOn 'loadDatabaseProps'

task loadDatabaseProps << {
    def propsFilePath = "${env}/database.properties"
    println "loading ${propsFilePath}"

    file(propsFilePath).withReader { reader ->
        configure(new Properties()) { load(reader) }.each { key, value ->
            def camelKey = key.split('\\.')*.capitalize().join()
            camelKey = camelKey.replaceFirst(camelKey[0], camelKey[0].toLowerCase())
            println "${camelKey}=${value}"
            project.ext[camelKey] = value
        }
    }

}

task initDatabase(dependsOn: ['loadDatabaseProps']) << {
    URLClassLoader loader = GroovyObject.class.classLoader
    configurations.mysql.each { File file ->
        loader.addURL(file.toURL())
    }

    def sql = Sql.newInstance(
            "jdbc:mysql://${dbHost}:${dbPort}/mysql",
            dbRootUsername,
            dbRootPassword,
            dbConnectionDriver
    )

    sql.execute "CREATE DATABASE IF NOT EXISTS liren default character set utf8 COLLATE utf8_general_ci"
    println "Prepare liren database."

    def result = sql.firstRow("SELECT COUNT(*) AS USERCOUNT FROM user WHERE User = ${dbConnectionUsername} and Host = ${dbHost}")
    if (result.USERCOUNT > 0) {
        println "User ${dbConnectionUsername} is already existed."
    } else {
        println "Creating User ${dbConnectionUsername} ..."
        sql.execute "CREATE USER ${dbConnectionUsername}@${dbHost} IDENTIFIED BY ${dbConnectionPassword}"
        sql.execute "GRANT ALL ON liren.* TO ${dbConnectionUsername}@${dbHost}"
        println "${dbConnectionUsername} created."
    }
}

updateDatabase.dependsOn 'initDatabase'
test.dependsOn 'updateDatabase'