import groovy.sql.Sql

ext {
    databaseMigrationBaseDir = 'database'
    liquibaseChangeLogFile = "${databaseMigrationBaseDir}/changelogs/changelog.xml"
    liquibaseChangeLogTable = 'liquibase_change_log'
    liquibaseChangeLogLockTable = 'liquibase_change_log_lock'
    liquibaseRollbackCount = 1
}


ant {
    ant.path(id: 'mysqlClasspath') {
        ant.pathelement(path: configurations.mysql.asPath)
    }
    taskdef resource: 'liquibasetasks.properties', classpath: configurations.liquibase.asPath

}

task updateDatabase {
    description 'Update to latest database.'
    group = 'database'
}

updateDatabase << {
    ant {
        updateDatabase(
                changeLogFile: liquibaseChangeLogFile,
                driver: dbConnectionDriver,
                url: dbConnectionUrl,
                username: dbConnectionUsername,
                password: dbConnectionPassword,
                promptOnNonLocalDatabase: 'false',
                dropFirst: 'false',
                classpathref: 'mysqlClasspath',
                databasechangelogtablename: liquibaseChangeLogTable,
                databasechangeloglocktablename: liquibaseChangeLogLockTable
        )
    }
}


task rollbackDatabase {
    description 'Rollback database migration.'
    group 'database'

}

rollbackDatabase << {
    ant {
        rollbackDatabase(
                changeLogFile: liquibaseChangeLogFile,
                driver: dbConnectionDriver,
                url: dbConnectionUrl,
                username: dbConnectionUsername,
                password: dbConnectionPassword,
                classpathref: 'mysqlClasspath',
                rollbackcount: liquibaseRollbackCount,
                databasechangelogtablename: liquibaseChangeLogTable,
                databasechangeloglocktablename: liquibaseChangeLogLockTable
        )
    }
}

task initDatabase {
    description 'Initialize database.'
    group 'database'
}

initDatabase << {

    def sql = sql()

    logger.quiet "Preparing database ${dbConnectionDatabase}..."
    sql.execute 'CREATE DATABASE IF NOT EXISTS ' + dbConnectionDatabase + ' DEFAULT CHARACTER SET UTF8 COLLATE UTF8_GENERAL_CI'

    def result = sql.firstRow("SELECT COUNT(*) AS USERCOUNT FROM user WHERE User = ${dbConnectionUsername}")

    if (result['USERCOUNT'] > 0) {
        logger.quiet "Database user ${dbConnectionUsername} is already existed."

    } else {
        logger.quiet "Creating database user ${dbConnectionUsername} ..."
        sql.execute "CREATE USER ${dbConnectionUsername}@'localhost' IDENTIFIED BY ${dbConnectionPassword}"
        sql.execute "CREATE USER ${dbConnectionUsername}@'%' IDENTIFIED BY ${dbConnectionPassword}"
    }

    logger.quiet "Granting database privileges to user ${dbConnectionUsername}..."
    sql.execute "GRANT ALL ON " + dbConnectionDatabase + ".* TO ${dbConnectionUsername}@'localhost'"
    sql.execute "GRANT ALL ON " + dbConnectionDatabase + ".* TO ${dbConnectionUsername}@'%'"

    logger.quiet "Database ${dbConnectionUsername} is ready."
}


task dropDatabase {
    description 'Drop database and user.'
    group 'database'
}

dropDatabase << {
    def sql = sql()
    logger.quiet "Dropping database ${dbConnectionDatabase}..."
    sql.execute 'DROP DATABASE IF EXISTS ' + dbConnectionDatabase

    logger.quiet "Dropping database user ${dbConnectionUsername}..."
    dropUser sql, dbConnectionUsername, '%'
    dropUser sql, dbConnectionUsername, 'localhost'
}

private def sql() {
    URLClassLoader loader = GroovyObject.class.classLoader
    configurations.mysql.each { File file ->
        loader.addURL(file.toURL())
    }

    return Sql.newInstance(
            "jdbc:mysql://${dbHost}:${dbPort}/mysql",
            dbRootUsername,
            dbRootPassword,
            dbConnectionDriver
    )
}


private def dropUser(sql, user, host){
    try{
    sql.execute "DROP USER ${user}@${host}"
    }catch (Exception e){
        //swallow failure
        logger.quiet "database user ${user} not exist."
    }
}

['dev', 'local', 'test'].each {
    if(env == it) initDatabase.dependsOn 'dropDatabase'
}

updateDatabase.dependsOn 'initDatabase'
test.dependsOn 'updateDatabase'